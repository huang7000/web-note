:::snippet `v-for`把一个数组对应为一组元素

1. 我们可以用`v-for`指令基于一个数组来渲染一个列表。
2. `v-for`指令需要使用`item in items`形式的特殊语法，其中`items`是源数据数组，而`item`则是被迭代的数组元素的别名。
3. `of`替代`in`作为分隔符，因为它是最接近`JavaScript`迭代器的语法

```html
<script src="https://unpkg.com/vue@next"></script>
<div id="app">
  <h2>item in items</h2>
  <ul>
    <li v-for="item in items">
      {{ item.name }}
    </li>
  </ul>
  <h2>item of items</h2>
  <ul>
    <li v-for="item of items">
      {{ item.name }}
    </li>
  </ul>
  <h2>(item, index) in items</h2>
  <ul>
    <li v-for="(item, index) in items">
      {{ index }} - {{ item.name }}
    </li>
  </ul>
  <h2>(item, index) of items</h2>
  <ul>
    <li v-for="(item, index) of items">
      {{ index }} - {{ item.name }}
    </li>
  </ul>
</div>
```

```javascript
const appOptions = {
  data() {
    return {
      items: [
        {
          name: "小强",
          age: 18,
        },
        {
          name: "小红",
          age: 17,
        },
      ],
    };
  },
};
Vue.createApp(appOptions).mount("#app");
```

:::

:::snippet `v-for`把一个对象对应为一组元素

> 在遍历对象时，是按`Object.keys()`的结果遍历，但是不能保证它的结果在不同的`JavaScript`引擎下是一致的。

```html
<script src="https://unpkg.com/vue@next"></script>
<div id="app">
  <h2>value in myObject</h2>
  <ul>
    <li v-for="value in myObject">
      {{ value }}
    </li>
  </ul>
  <h2>(value, name) in myObject</h2>
  <ul>
    <li v-for="(value, name) in myObject">
      {{ name }}: {{ value }}
    </li>
  </ul>
  <h2>(value, name, index) in myObject</h2>
  <ul>
    <li v-for="(value, name, index) in myObject">
      {{ index }}. {{ name }}: {{ value }}
    </li>
  </ul>
  <h2>(value, name, index) of myObject</h2>
  <ul>
    <li v-for="(value, name, index) of myObject">
      {{ index }}. {{ name }}: {{ value }}
    </li>
  </ul>
</div>
```

```javascript
const appOptions = {
  data() {
    return {
      myObject: {
        title: "How to do lists in Vue",
        author: "Jane Doe",
        publishedAt: "2020-03-22",
      },
    };
  },
};
Vue.createApp(appOptions).mount("#app");
```

:::

:::snippet `key`

1. 不提供`key`只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。
2. 尽可能在使用`v-for`时提供`key`，除非遍历输出的`DOM`内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。
3. `key`它是`Vue`识别节点的一个通用机制

```html
<script src="https://unpkg.com/vue@next"></script>
<div id="app">
  <ul>
    <li v-for="item in items" v-bind:key="item.id">
      {{ item }}
    </li>
  </ul>
</div>
```

```javascript
const appOptions = {
  data() {
    return {
      items: [
        {
          message: "Foo",
          tiltle: "ceshi001",
        },
        {
          message: "Bar",
          tiltle: "ceshi002",
        },
      ],
    };
  },
};
Vue.createApp(appOptions).mount("#app");
```

:::

:::snippet 数组变异方法 (`mutation method`)

> 变异方法 (`mutation method`)，顾名思义，会改变被这些方法调用的原始数组。

1. `push()`方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度
2. `pop()`方法用于删除数组的最后一个元素
3. `shift()`方法用于删除数组的第一个元素，并返回该元素。
4. `unshift()`方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。
5. `splice()`方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。
6. `sort()`方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。
7. `reverse()`方法用于颠倒排列数组元素，返回改变后的数组。

```javascript
var arr = [];
arr.push(1); // 1
arr.push("a"); // 2
arr.push(true, {}); // 4
arr; // [1, 'a', true, {}]
arr.pop(); // {}
arr; // [1, 'a', true]
arr.shift(); // 1
arr; // [ 'a', true]
arr.unshift("x"); // 3
arr; // ['x', 'a', true]
// 1:删除的功能 splice(index,count)
// index:开始位置的索引 count:要删除元素的个数
// 返回的是包含被删除元素的数组对象
arr = ["a", "b", "c", "d"];
var newArr = arr.splice(1, 2); //会把b,c两个元素给删除掉
console.log(arr); //['a','d']
console.log(newArr); //返回['b','c']
// 2:插入功能 splice(index,0,value)
// index:插入元素的索引值 value:插入的值
// 返回的是空数组
arr = ["a", "b", "c", "d"];
newArr1 = arr.splice(2, 0, "张三");
console.log(arr); //输出=['a','b','张三','c','d']
console.log(newArr1); //[]
// 3:替换功能 splice(index,num,value)
// index:开始的索引位置 num:删除项的数(如果num为0，就是插入功能) value:插入的值
// 返回:返回的是包含被删除的元素的数组对象
arr = ["a", "b", "c", "d"];
newArr2 = arr.splice(2, 2, "张三", "李四");
console.log(arr); //输出=['a','b','张三','李四']
console.log(newArr2); //输入['c','d']
arr = [4, 2, 3, 1];
arr.sort(); // [1, 2, 3, 4]
arr.reverse(); // [4, 3, 2, 1]
```

:::

:::snippet 非变异方法
非变异 (`non-mutating method`) 方法 它们不会改变原始数组，而总是返回一个新数组。

1. `filter()`创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
2. `concat()`连接两个或更多的数组，并返回结果。
3. `slice()`它能够基于当前数组中的一个或多个项创建一个新数组。

```javascript
var arr = [1, 2, 3, 4];
arr = arr.filter(function(item) {
  return item / 2 === 0;
});
arr; // 2,4
var arr1 = ["red", "green"];
var arr2 = ["blue", "yellow"];
var arr3 = arr1.concat(arr2); //'red', 'green', 'blue', 'yellow'
var colors = ["red", "green", "blue", "yellow", "purple"]; //  red,green,blue,yellow,purple
// 在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。
var colors2 = colors.slice(1); //  green,blue,yellow,purple
// 两个参数，该方法返回起始和结束位置之间的项-----但不包括结束位置的项。
var colors3 = colors.slice(1, 4); //  green,blue,yellow
```

:::

:::snippet 显示过滤/排序结果

```html
<script src="https://unpkg.com/vue@next"></script>
<div id="app">
  <h2>计算属性</h2>
  <ul>
    <li v-for="item in evenNumbers">
      {{item}}
    </li>
  </ul>
  <h2>方法</h2>
  <ul>
    <li v-for="item in even(numbers)">
      {{item}}
    </li>
  </ul>
</div>
```

```javascript
const appOptions = {
  data() {
    return {
      numbers: [1, 2, 3, 4, 5],
    };
  },
  methods: {
    even(numbers) {
      return numbers.filter((number) => number % 2 !== 0);
    },
  },
  computed: {
    evenNumbers() {
      return this.numbers.filter((number) => number % 2 === 0);
    },
  },
};
Vue.createApp(appOptions).mount("#app");
```

:::

:::snippet 一段取值范围的`v-for`

> n 必须大于等于 1，从 1 开始到 n

```html
<script src="https://unpkg.com/vue@next"></script>
<div id="app">
  <ul>
    <li v-for="n in range">
      {{n}}
    </li>
  </ul>
</div>
```

```javascript
const appOptions = {
  data() {
    return {
      range: 10,
    };
  },
};
Vue.createApp(appOptions).mount("#app");
```

:::

:::snippet 在`<template>`中使用`v-for`

```html
<script src="https://unpkg.com/vue@next"></script>
<div id="app">
  <ul>
    <template v-for="item in items">
      <li>{{ item.msg }}</li>
      <li class="divider" role="presentation"></li>
    </template>
  </ul>
</div>
```

```javascript
const appOptions = {
  data() {
    return {
      items: [
        {
          msg: "shenme",
          id: 1,
        },
        {
          msg: "dongxi",
          id: 11,
        },
      ],
    };
  },
};
Vue.createApp(appOptions).mount("#app");
```

:::

:::snippet `v-for`with`v-if`

>3.x 版本中 v-if 总是优先于 v-for 生效。
>2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。

```html
<script src="https://unpkg.com/vue@next"></script>

<div id="app">
  <h2>for if show</h2>
  <ul v-if="todos.length">
    <!-- v-if="!todo.isComplete" 会报错 v-if先生效所以报错了。-->
    <!-- v-show="!todo.isComplete" 没问题 -->
    <li v-for="todo in todos" v-show="!todo.isComplete">
      {{ todo }}
    </li>
  </ul>
  <p v-else>No todos left!</p>
</div>
```

```javascript
const appOptions = {
  data() {
    return {
      todos: [
        {
          msg: "shenme",
          isComplete: true,
        },
        {
          msg: "dongxi",
          isComplete: false,
        },
        {
          msg: "nubi",
          isComplete: true,
        },
        {
          msg: "laji",
          isComplete: false,
        },
        {
          msg: "hello",
          isComplete: true,
        },
      ],
    };
  },
};
Vue.createApp(appOptions).mount("#app");
```

:::

:::snippet 组件的`v-for`

> 当在组件上使用`v-for`时，`key`现在是必须的。

```html
<script src="https://unpkg.com/vue@next"></script>
<div id="app">
  <form @submit.prevent="addTodo">
    <label for="new-todo">add todo</label>
    <input v-model="nextTitle" placeholder="input a new todo" id="new-todo" />
    <button>Add</button>
  </form>
  <ul v-if="todos.length">
    <todo-item
      v-for="(todo,index) in todos"
      :key="todo.id"
      :title="todo.title"
      @remove="todos.splice(index,1)"
    >
    </todo-item>
  </ul>
  <p v-else>No todos !</p>
</div>
```

```javascript
const appOptions = {
  data() {
    return {
      nextId: 2,
      nextTitle: "",
      todos: [
        {
          id: 1,
          title: "test",
        },
      ],
    };
  },
  methods: {
    addTodo() {
      let nextTodo = {
        id: this.nextId,
        title: this.nextTitle,
      };
      this.todos.push(nextTodo);
      this.nextId++;
    },
  },
};
const app = Vue.createApp(appOptions);
app.component("todo-item", {
  template: `
            <li>
                {{ title }}
                <button @click="$emit('remove')">Remove</button>
            </li>
        `,
  props: ["title"],
});
app.mount("#app");
```

:::
