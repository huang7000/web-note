:::snippet 计算属性
1. 计算属性是基于它们的依赖进行缓存的。
2. 只在相关依赖发生改变时它们才会重新求值。

```javascript
//计算属性 reversedMessage。我们提供的函数将用作属性 vm.reversedMessage 的 getter 函数：
let vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
console.log(vm.reversedMessage) // => 'olleH'
vm.message = 'Goodbye'
console.log(vm.reversedMessage) // => 'eybdooG'
```

```html
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>
```

:::

:::snippet 计算属性缓存 vs 方法
1. 计算属性只在相关依赖发生改变时它们才会重新求值。
2. 方法 当触发重新渲染时，调用方法将总会再次执行函数。

```javascript
let indexComputed = 0;
let indexMethod = 0;
let app02 = new Vue({
  el: "#app02",
  data: {
    message: "翻转字符串",
    hello: "Hello World",
    title: "Hello World"
  },
  computed: {
    reversedMessage: function() {
      //console.log('computed :reversedMessage;date:'+ Date.now());
      indexComputed++;
      return (
        "reversedMessage" +
        this.message
          .split("")
          .reverse()
          .join("") +
        Date.now()
      );
    }
  },
  methods: {
    reversedFun: function() {
      //console.log('methods'+'reversedMessage');
      //console.log('methods:reversedMessage;date:'+ Date.now());
      indexMethod++;
      return (
        "reversedFun" +
        this.message
          .split("")
          .reverse()
          .join("") +
        Date.now()
      );
    }
  }
});

console.log("indexComputed:" + indexComputed + ";indexMethod:" + indexMethod); //indexComputed:1;indexMethod:1
console.log(app02.reversedMessage); //reversedMessage串符字转翻1548173233202
console.log("indexComputed:" + indexComputed + ";indexMethod:" + indexMethod); //indexComputed:1;indexMethod:1
console.log(app02.reversedFun()); //reversedFun串符字转翻1548173233208
console.log("indexComputed:" + indexComputed + ";indexMethod:" + indexMethod); //indexComputed:1;indexMethod:2
app02.message = "message";
console.log("indexComputed:" + indexComputed + ";indexMethod:" + indexMethod); //indexComputed:1;indexMethod:2
console.log(app02.reversedMessage);
console.log("indexComputed:" + indexComputed + ";indexMethod:" + indexMethod); //indexComputed:2;indexMethod:2
console.log(app02.reversedFun());
console.log("indexComputed:" + indexComputed + ";indexMethod:" + indexMethod); //indexComputed:2;indexMethod:3
```

```html
<div id="app02">
  <p>Original Message：{{message}}</p>
  <p>Computer Reverse Message：{{reversedMessage}}</p>
  <p>reversedFun：{{reversedFun()}}</p>
</div>
```

:::

:::snippet 计算属性 vs 侦听属性

```javascript
let app03 = new Vue({
  el: "#app03",
  data: {
    firstName: "ningyuan",
    lastName: "xihuang",
    fullName: "ningyuan xihuang"
  },
  watch: {
    firstName: function(val) {
      this.fullName = val + " " + this.lastName;
    },
    lastName: function(val) {
      this.fullName = this.firstName + " " + val;
    }
  },
  computed: {
    xingming: function() {
      return this.firstName + " " + this.lastName;
    }
  }
});
app03.firstName = "wuming";
app03.firstName = "donghuang";
```

```html
<div id="app03">
  <p>firstName：{{firstName}}</p>
  <p>lastName：{{lastName}}</p>
  <p>fullName：{{fullName}}</p>
  <p>fullName：{{xingming}}</p>
</div>
```

:::

:::snippet 计算属性的 setterh 和 getter

```javascript
let app04 = new Vue({
  el: "#app04",
  data: {
    firstName: "ningyuan",
    lastName: "xihuang"
  },
  computed: {
    xingming: function() {
      return this.firstName + " " + this.lastName;
    },
    fullName: {
      // getter
      get: function() {
        return this.firstName + " " + this.lastName;
      },
      // setter
      set: function(newValue) {
        var names = newValue.split(" ");
        this.firstName = names[0];
        this.lastName = names[names.length - 1];
      }
    }
  }
});
app04.fullName = "神魔非我 萧无名";
```

```html
<div id="app04">
  <p>firstName：{{firstName}}</p>
  <p>lastName：{{lastName}}</p>
  <p>fullName：{{fullName}}</p>
  <p>xingming:{{xingming}}</p>
</div>
```

:::

:::snippet 侦听器

```html
<!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 -->
<!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 -->
<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
<script>
  var app05 = new Vue({
    el: "#app05",
    data: {
      question: "",
      answer: "I cannot give you an answer until you ask a question!"
    },
    watch: {
      // 如果 `question` 发生改变，这个函数就会运行
      question: function(newQuestion, oldQuestion) {
        this.answer = "Waiting for you to stop typing...";
        this.debouncedGetAnswer();
      }
    },
    created: function() {
      // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。
      // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率
      // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于
      // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，
      // 请参考：https://lodash.com/docs#debounce
      this.debouncedGetAnswer = _.debounce(this.getAnswer, 500);
    },
    methods: {
      getAnswer: function() {
        if (this.question.indexOf("?") === -1) {
          this.answer = "Questions usually contain a question mark. ;-)";
          return;
        }
        this.answer = "Thinking...";
        var vm = this;
        axios
          .get("https://yesno.wtf/api")
          .then(function(response) {
            vm.answer = _.capitalize(response.data.answer);
          })
          .catch(function(error) {
            vm.answer = "Error! Could not reach the API. " + error;
          });
      }
    }
  });
</script>
<div id="app05">
  <p>
    Ask a yes/no question:
    <input v-model="question" />
  </p>
  <p>{{ answer }}</p>
</div>
```

:::
