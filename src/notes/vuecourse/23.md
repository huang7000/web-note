:::snippet 渲染函数
渲染函数，它比模板更接近编译器。

```html
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<div id="app" class="demo">
  <anchored-heading :level="1">第1标题 Hello</anchored-heading>
  <anchored-heading :level="2">第2标题 Hello</anchored-heading>
  <anchored-heading :level="4">第4标题 Hello</anchored-heading>
</div>
```

```javascript
Vue.component("anchored-heading", {
  render: function(createElement) {
    return createElement(
      "h" + this.level, //标签名称
      this.$slots.default //字节点数组
    );
  },
  //简写
  // render(h) {
  //   return h(
  //     'h' + this.level, //标签名称
  //     this.$slots.default //字节点数组
  //   )
  // },
  props: {
    level: {
      type: Number,
      required: true,
    },
  },
});
new Vue({
  el: "#app",
});
```

:::
:::snippet 节点、树以及虚拟 DOM
每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。
`虚拟 DOM` `Vue` 通过建立一个虚拟 DOM 来追踪自己要如何改变`真实 DOM`。
`createNodeDescription`，因为它所包含的信息会告诉 `Vue` 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为`虚拟节点 (virtual node)`，也常简写它为`VNode`。
`虚拟 DOM`是我们对由 Vue 组件树建立起来的整个 `VNode 树`的称呼。

模板 Html

```html
<h1>{{ blogTitle }}</h1>
```

渲染函数

```javascript
render: function (createElement) {
  return createElement('h1', this.blogTitle)
}
```

:::
:::snippet createElement 参数

1. 第一个参数是一个 html 标签，前面已经说了这个函数是用来创建元素，但是创建什么元素呢，那就取决于第一个参数，而这个参数就是所需创建元素的 html 标签，如 div, span, p 等.
2. 第二个参数是可选参数，这个参数是用来描述所创建的元素的，为所创建的元素设置属性，如 class, style, props 等等.
3. 第三个参数就是创建的元素的子节点了。由 createElement() 构建而成，
   或简单的使用字符串来生成“文本结点”。也同样是可选参数。

```javascript
// @returns {VNode}
createElement(
  // {String | Object | Function}
  // 一个 HTML 标签名、组件选项对象，或者
  // resolve 了上述任何一种的一个 async 函数。必填项。
  "div",

  // {Object}
  // 一个与模板中 attribute 对应的数据对象。可选。
  {
    // (详情见下一节)
  },

  // {String | Array}
  // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，
  // 也可以使用字符串来生成“文本虚拟节点”。可选。
  [
    "先写一些文字",
    createElement("h1", "一则头条"),
    createElement(MyComponent, {
      props: {
        someProp: "foobar",
      },
    }),
  ]
);
```

:::

:::snippet 深入 data object 参数
正如在模板语法中，v-bind:class 和 v-bind:style ，会被特别对待一样，在 VNode 数据对象中，下列属性名是级别最高的字段。该对象也允许你绑定普通的 HTML 特性，就像 DOM 属性一样，比如 innerHTML (这会取代 v-html 指令)。

```javascript
{
  // 和`v-bind:class`一样的 API
  'class': {
    foo: true,
    bar: false
  },
  // 和`v-bind:style`一样的 API
  style: {
    color: 'red',
    fontSize: '14px'
  },
  // 正常的 HTML 特性
  attrs: {
    id: 'foo'
  },
  // 组件 props
  props: {
    myProp: 'bar'
  },
  // DOM 属性
  domProps: {
    innerHTML: 'baz'
  },
  // 事件监听器基于 `on`
  // 所以不再支持如 `v-on:keyup.enter` 修饰器
  // 需要手动匹配 keyCode。
  on: {
    click: this.clickHandler
  },
  // 仅对于组件，用于监听原生事件，而不是组件内部使用 `vm.$emit` 触发的事件。
  nativeOn: {
    click: this.nativeClickHandler
  },
  // 自定义指令. 注意事项：不能对绑定的旧值设值
  // Vue 会为您持续追踪
  directives: [
    {
      name: 'my-custom-directive',
      value: '2',
      expression: '1 + 1',
      arg: 'foo',
      modifiers: {
        bar: true
      }
    }
  ],
  // Scoped slots in the form of
  // { name: props => VNode | Array<VNode> }
  scopedSlots: {
    default: props => createElement('span', props.text)
  },
  // 如果组件是其他组件的子组件，需为 slot 指定名称
  slot: 'name-of-slot',
  // 其他特殊顶层属性
  key: 'myKey',
  ref: 'myRef'
}
```

:::

:::snippet 完整示例

```html
<div id="app">
  <my-heading :level="2">
    <p>Hello Chain</p>
  </my-heading>
</div>
```

```javascript
var getChildrenTextContent = function(children) {
  return children
    .map(function(node) {
      return node.children ? getChildrenTextContent(node.children) : node.text;
    })
    .join("");
};
Vue.component("my-heading", {
  render: function(createElement) {
    var headingId = getChildrenTextContent(this.$slots.default)
      .toLowerCase()
      .replace(/\W/g, "-")
      .replace(/(^\-|\-$)/g, "");
    return createElement("h" + this.level, [
      createElement(
        "a",
        {
          attrs: {
            name: headingId,
            href: "#" + headingId,
          },
        },
        this.$slots.default
      ),
    ]);
  },
  props: {
    level: {
      type: Number,
      required: true,
    },
  },
});

new Vue({
  el: "#app",
});
```

:::

:::snippet 约束

组件树中的所有 VNode 必须是唯一的。这意味着，下面的渲染函数是不合法的：

```javascript
render: function (createElement) {
  var myParagraphVNode = createElement('p', 'hi') 
  return createElement('div', [
    // 错误 - 重复的 VNode
    myParagraphVNode, myParagraphVNode
  ])
}
```

工厂函数来实现。例如，下面这渲染函数用完全合法的方式渲染了 20 个相同的段落：

```javascript
render: function (createElement) {
  return createElement('div',
    Array.apply(null, { length: 20 }).map(function () {
      return createElement('p', 'hi')
    })
  )
}
```

:::
