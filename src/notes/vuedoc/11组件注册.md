:::snippet 组件名

> 使用 kebab-case(短横线分隔命名) "my-component-name"
> 使用 PascalCase "MyComponentName"
> 直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。建议 使用 kebab-case。

```html
<div id="app01">
    <my-component-name v-bind="post"></my-component-name>
</div>
<div id="app02">
    <MyComponentName v-bind="post"></MyComponentName>
</div>
```

```javascript
Vue.component('my-component-name', {
    /* ... */
});
Vue.component('MyComponentName', {
    /* ... */
});
```

:::

:::snippet 全局注册

```html
<div id="app01">
    <my-component-name v-bind="post"></my-component-name>
    <my-component-test v-bind="post"></my-component-test>
</div>
```

```javascript
Vue.component('my-component-name', {
    /* ... */
});
Vue.component('my-component-test', {
    /* ... */
});
new Vue({ el: '#app01' });
```

:::

:::snippet 局部注册

```javascript
var ComponentA = {
    /* ... */
};
var ComponentB = {
    /* ... */
};
var ComponentC = {
    /* ... */
};
new Vue({
    el: '#app01',
    compnents: {
        'component-a': ComponentA,
        'component-b': ComponentB
    }
});

new Vue({
    el: '#app01',
    compnents: {
        'component-a': ComponentA,
        'component-b': ComponentB
    }
});
```

> 注意局部注册的组件在其子组件中不可用。
> `ComponentA` 在 `ComponentD` 中可用

```javascript
var ComponentA = {
    /* ... */
};

var ComponentD = {
    components: { 'component-a': ComponentA }
    //...
};

new Vue({
    el: '#app02',
    compnents: {
        'component-d': ComponentD,
        'component-b': ComponentB
    }
});
```

> 局部组件实例

```html
<div id="app01"></div>
```

```javascript
let ComponentA = {
    data: function() {
        return {
            count: 0
        };
    },
    template:
        '<button v-on:click="count++">You clicked me {{ count}} times.</button>'
};
new Vue({
    el: '#app01',
    components: {
        ComponentA: ComponentA
    },
    template: '<ComponentA></ComponentA>'
});
```

:::

:::snippet 在模块系统中局部注册

> Babel 和 webpack 使用 ES2015 模块
> 在 ES2015+ 中，在对象中放一个类似 ComponentA 的变量名其实是 ComponentA: ComponentA 的缩写
> 这个变量名同时是：用在模板中的自定义元素的名称，包含了这个组件选项的变量名
> 在一个假设的 ComponentB.js 或 ComponentB.vue 文件中
> 现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了。

```javascript
import ComponentA from './ComponentA';
import ComponentC from './ComponentC';

export default {
    components: {
        ComponentA,
        ComponentC
    }
    // ...
};
```

:::

:::snippet 基础组件的自动化全局注册

> 应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码

```javascript
import Vue from 'vue';
import upperFirst from 'lodash/upperFirst';
import camelCase from 'lodash/camelCase';

const requireComponent = require.context(
    // 其组件目录的相对路径
    './components',
    // 是否查询其子目录
    false,
    // 匹配基础组件文件名的正则表达式
    /Base[A-Z]\w+\.(vue|js)$/
);

requireComponent.keys().forEach(fileName => {
    // 获取组件配置
    const componentConfig = requireComponent(fileName);

    // 获取组件的 PascalCase 命名
    const componentName = upperFirst(
        camelCase(
            // 剥去文件名开头的 `./` 和结尾的扩展名
            fileName.replace(/^\.\/(.*)\.\w+$/, '$1')
        )
    );

    // 全局注册组件
    Vue.component(
        componentName,
        // 如果这个组件选项是通过 `export default` 导出的，
        // 那么就会优先使用 `.default`，
        // 否则回退到使用模块的根。
        componentConfig.default || componentConfig
    );
});
```

:::
