{"version":3,"sources":["webpack:///./src/demos/tsDemo/test.ts"],"names":["x","console","log"],"mappings":"mGAkNA,IAAIA,EAEJA,EAAI,EACJC,QAAQC,IAAIF,GACZA,GAAI,EACJC,QAAQC,IAAIF,GACZA,GAAGA,EACHC,QAAQC,IAAIF","file":"js/chunk-2d0f00a1.82a6b68f.js","sourcesContent":["// function identity(ary:any):any{\n//   return ary;\n// }\n// console.log(identity(555))\n// console.log(identity({name:\"huang 700\" ,age:18}))\n\n// function identitype<T>(ary:T):T{\n//   return ary;\n// }\n// //传入所有的参数，包含类型参数\n// let outputT = identitype<string>(\"myString\");\n// //利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定T的类型：\n// let output = identitype(\"myString\");\n// console.log(identitype({name:\"huang 700\" ,age:18,sex:\"男\"}))\n\n// function identity<T>(arg: T): T {\n//   return arg;\n// }\n// let myIdentity: <T>(arg: T) => T = identity;\n// let yourIdentity: <U>(arg: U) => U = identity;\n// let myIdentity2: {<T>(arg: T): T} = identity;\n\n// enum Color {\n//   red, blue\n// }\n// enum Color2 {\n//   red, blue\n// }\n// enum E {\n//   mm,\n//   A = mm+B,  B, // error! 'A' is not constant-initialized, so 'B' needs an initializer\n\n// }\n\n// enum E {\n//   Foo,\n//   Bar,\n// }\n\n// function f(x: E) {\n//   if (x !== E.Foo) {\n//       //             ~~~~~~~~~~~\n//       // Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'.\n//   }\n// }\n\n// const enum Enum {\n//   A = 1,\n//   B = A * 2\n// }\n\n// const enum Directions {\n//   Up,\n//   Down,\n//   Left,\n//   Right\n// }\n\n// let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]\n// console.log(directions)\n// enum Enum2 {\n//   A\n// }\n// let a = Enum2.A;\n// let nameOfA = Enum2[a]; // \"A\"\n// console.log(nameOfA)\n// let x = 3;\n// let someValue: any = \"this is a string\";\n// let strLength: number = (<string>someValue).length;\n// let strLength2: number = (someValue as string).length;\n\n// let y = [0, 1, null];\n// console.log(\"y的数据类型\")\n// console.log(typeof y)\n\n// let x:number|string = 1;\n// console.log(\"x的数据类型\")\n// console.log(typeof x)\n// class Animal{}\n// class Rhino{}\n// class Elephant{}\n// class Snake{}\n// let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];\n// let zoo2 = [new Rhino(), new Elephant(), new Snake()];\n// console.log(typeof zoo)\n// console.log(typeof zoo2)\n\n// // window.onmousedown = function(mouseEvent) {\n// //   console.log(mouseEvent.button);  //<- Error\n// // };\n// window.onmousedown = function(mouseEvent: any) {\n//   console.log(mouseEvent.button);  //<- Now, no error is given\n// };\n\n// function invokeLater(args: any[], callback: (...args: any[]) => void) {\n//     /* ... Invoke callback with 'args' ... */\n// }\n\n// // Unsound - invokeLater \"might\" provide any number of arguments\n// invokeLater([1, 2], (x, y) => console.log(x + ', ' + y));\n\n// // Confusing (x and y are actually required) and undiscoverable\n// invokeLater([1, 2], (x?, y?) => console.log(x + ', ' + y));\n\n// class Animal {\n//   feet: number=5;\n//   constructor(name: string, numFeet: number) { }\n// }\n\n// class Size {\n//   feet: number=6;\n//   constructor(numFeet: number) { }\n// }\n\n// let a: Animal=new Animal(\"123\",456);\n// let s: Size=new Size(123);;\n// a = s;  // OK\n// s = a;  // OK\n\n// interface Empty<T> {\n// }\n// let x: Empty<number>=123;\n// let y: Empty<string>=\"abc\";\n// console.log(x)\n// console.log(y)\n// x = y;  // OK, because y matches structure of x\n// console.log(x)\n// console.log(y)\n\n// function extend<T, U>(first: T, second: U): T & U {\n//     let result = <T & U>{};\n//     for (let id in first) {\n//         (<any>result)[id] = (<any>first)[id];\n//     }\n//     for (let id in second) {\n//         if (!result.hasOwnProperty(id)) {\n//             (<any>result)[id] = (<any>second)[id];\n//         }\n//     }\n//     return result;\n// }\n\n// class Person {\n//     constructor(public name: string) { }\n// }\n// interface Loggable {\n//     log(): void;\n// }\n// class ConsoleLogger implements Loggable {\n//     constructor(public id: Number) { }\n//     log() {\n//         console.log(this.id)\n//         // ...\n//     }\n// }\n// var jim = extend(new Person(\"Jim\"), new ConsoleLogger(123));\n// var n = jim.name;\n// jim.log();\n// console.log(jim)\n\n// let index:Number|string;\n// index=\"hello\"\n// index=123\n// index=[] //error\n// type Name = string;\n// type NameResolver = () => string;\n// type NameOrResolver = Name | NameResolver;\n// function getName(n: NameOrResolver): Name {\n//     if (typeof n === 'string') {\n//         return n;\n//     }\n//     else {\n//         return n();\n//     }\n// }\n// type Container<T> = { value: T };\n// //类型别名不能出现在声明右侧的任何地方。\n// type Names = Array<Names>; // error\n\n\n// let s1 = Symbol('foo');\n// Symbol.keyFor(s1) // undefined\n// let s2 = Symbol('foo');\n// console.log(s1 === s2)\n// //注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。\n// let sfor1 = Symbol.for('foo');\n// Symbol.keyFor(sfor1) // \"foo\"\n// let sfor2 = Symbol.for('foo');\n// console.log(sfor1 === sfor2)\n// let numbers = [1, 2, 3];\n// for (let num of numbers) {\n//     console.log(num);\n// }\n\n\n// let arr1 = [\"c\", \"d\"];\n// [\"a\", \"b\"].concat(arr1, \"e\"); // ['a', 'b', 'c', 'd', 'e']\n// console.log(arr1[Symbol.isConcatSpreadable]); // undefined\n// let arr2 = [\"c\", \"d\"];\n// arr2[Symbol.isConcatSpreadable] = false;\n// [\"a\", \"b\"].concat(arr2, \"e\"); // ['a', 'b', ['c','d'], 'e']\n// let obj = { length: 2, 0: \"c\", 1: \"d\" };\n// [\"a\", \"b\"].concat(obj, \"e\"); // ['a', 'b', obj, 'e']\n// console.log([\"a\", \"b\"].concat(obj, \"e\") )\n// console.log(obj[Symbol.isConcatSpreadable]); // undefined\n// obj[Symbol.isConcatSpreadable] = true;\n// [\"a\", \"b\"].concat(obj, \"e\"); // ['a', 'b', 'c', 'd', 'e']\n// console.log([\"a\", \"b\"].concat(obj, \"e\") )\n\n/** @type {number} */\nvar x;\n\nx = 0;      // OK\nconsole.log(x);\nx = false;  // Error: boolean is not assignable to number\nconsole.log(x);\nx=!x;\nconsole.log(x);"],"sourceRoot":""}