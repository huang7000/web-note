(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0bd58c"],{"2c38":function(e,t,p){"use strict";p.r(t);var l=function(){var e=this,t=e.$createElement,p=e._self._c||t;return p("section",[p("hv-snippet",{attrs:{title:""}},[p("template",{slot:"title"},[p("p",[e._v("使用命名空间")])]),p("p",[e._v("命名空间是位于全局命名空间下的一个普通的带有名字的JavaScript对象。 这令命名空间十分容易使用。 它们可以在多文件中同时使用，并通过 --outFile结合在一起。 命名空间是帮你组织Web应用不错的方式，你可以把所有依赖都放在HTML页面的 "),p("code",{pre:!0},[e._v("<script>")]),e._v("标签里。")])],2),p("hv-snippet",{attrs:{title:""}},[p("template",{slot:"title"},[p("p",[e._v("使用模块")])]),p("p",[e._v("像命名空间一样，模块可以包含代码和声明。 不同的是模块可以 声明它的依赖。\n模块会把依赖添加到模块加载器上（例如CommonJs / Require.js）。")]),p("blockquote",[p("p",[e._v("对于Node.js应用来说，模块是默认并推荐的组织代码的方式。")])])],2),p("hv-snippet",{attrs:{title:""}},[p("template",{slot:"title"},[p("p",[e._v("命名空间和模块的陷阱")])]),p("p",[e._v("对模块使用"),p("code",{pre:!0},[e._v("/// <reference>")]),e._v("\n一个常见的错误是使用"),p("code",{pre:!0},[e._v("/// <reference>")]),e._v("引用模块文件，应该使用import。")]),p("blockquote",[p("p",[e._v("不应该对模块使用命名空间，使用命名空间是为了提供逻辑分组和避免命名冲突。\n模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。")])])],2)],1)},n=[],o=p("2877"),r={},s=Object(o["a"])(r,l,n,!1,null,null,null);t["default"]=s.exports}}]);
//# sourceMappingURL=chunk-2d0bd58c.84429132.js.map